<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coder Jay-Blog</title>
    <description>Coder Jay's persional blog</description>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Coder Jay</name>
      <email>hejiedhj@.163.com</email>
      <uri>https://jay-dh.github.io/</uri>
    </author>
    
      <item>
        <title>汇编语言简述</title>
        <description>&lt;h1 id=&quot;汇编的基本概念&quot;&gt;汇编的基本概念&lt;/h1&gt;

&lt;h1 id=&quot;arm汇编&quot;&gt;arm汇编&lt;/h1&gt;

&lt;h1 id=&quot;x86_64汇编&quot;&gt;x86_64汇编&lt;/h1&gt;
</description>
        <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000//reverse-engineering-asm</link>
        <link href="http://localhost:4000/reverse-engineering-asm"/>
        <guid isPermaLink="true">http://localhost:4000/reverse-engineering-asm</guid>
      </item>
    
      <item>
        <title>Java语言的逆向(Android APP)</title>
        <description>&lt;p&gt;Java语言的逆向比较简单，只说一些关键思路和小技巧。下面以QQ音乐为例，讲述逆向的基本过程。&lt;/p&gt;

&lt;h2 id=&quot;静态分析&quot;&gt;静态分析&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;将APK反编译成比较方便理解的代码（如smali、Java代码等），进行静态分析，了解代码的流程和设计逻辑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;将apk反编译成smali代码&quot;&gt;将APK反编译成smali代码&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apktool d QQMusic72282.apk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;反编译出如下文件：
&lt;img src=&quot;./assets/rve-android/apk-smali.png&quot; alt=&quot;apk smali&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;将apk反编译成jar包&quot;&gt;将APK反编译成Jar包&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unzip &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; ./QQMusic72282-unzip QQMusic72282.apk &lt;span class=&quot;c&quot;&gt;# 解压APK&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ./QQMusic72282-unzip
d2j-dex2jar.sh classes.dex &lt;span class=&quot;c&quot;&gt;# dex转jar&lt;/span&gt;
d2j-dex2jar.sh classes2.dex
d2j-dex2jar.sh classes3.dex
d2j-dex2jar.sh classes4.dex
d2j-dex2jar.sh classes5.dex
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到jar包后直接用JD-GUI打开，即可查看Java代码了。&lt;/p&gt;

&lt;p&gt;但多个jar文件用JD-GUI查看很不方便，可以使用以下方法将多个jar合并成一个：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;tmp
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;tmp
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes-dex2jar.jar
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes2-dex2jar.jar
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes3-dex2jar.jar
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes4-dex2jar.jar
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes5-dex2jar.jar

&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../
jar &lt;span class=&quot;nt&quot;&gt;-cvf&lt;/span&gt; classes-combined.jar &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; tmp &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用JD-GUI打开classes-combine.jar，可查看反编译的Java如下所示：
&lt;img src=&quot;./assets/rve-android/apk-to-jar-analysis.png&quot; alt=&quot;analysis jd-gui&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;动态分析&quot;&gt;动态分析&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过断点调试手段，来让APP可以断点单步执行，并通过实时读取变量的值来分析代码的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;准备工具&quot;&gt;准备工具&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;userdebug版&lt;/strong&gt;的Android手机。&lt;/li&gt;
  &lt;li&gt;Android Stuido&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么是userdebug版的？因为userdebug版的系统，所有的应用都是debuggable的，这样就可以通过Android Studio开启调试给应用打断点调试。网上也有其他手段，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;反编译APK在manifest.xml文件增加debuggable属性；&lt;/li&gt;
  &lt;li&gt;使用xposed框架，借助框架强制开启应用的debuggable属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但这些方案都有一些问题，方法1在修改了manifest.xml文件后，需要给apk重新打包签名，因此不适用于有签名验证的应用（如喜马拉雅APK重签名后安装，应用会抛签名不合法的异常）；方法2对于低版本Android可能适用，高版本的安卓（实测Android 7.0）已经行不通了。&lt;/p&gt;

&lt;h3 id=&quot;打开项目&quot;&gt;打开项目&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开Android Studio&lt;/li&gt;
  &lt;li&gt;File –&amp;gt; Open –&amp;gt; 选择静态分析中反编译的smali源码目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;QQMusic72282\&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Mark smali及所有smali_classesx为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sources Root&lt;/code&gt;
&lt;img src=&quot;./assets/rve-android/as-setup-src.png&quot; alt=&quot;as setup src&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Run –&amp;gt; Edit Configurations –&amp;gt; 点击&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;Remote&lt;/code&gt;Configuration
&lt;img src=&quot;./assets/rve-android/as-setup-debugger-01.png&quot; alt=&quot;as setup debugger01&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;修改名字为QQMusic-Debugger，端口号设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;8700&lt;/code&gt;后点击&lt;code class=&quot;highlighter-rouge&quot;&gt;OK&lt;/code&gt;
&lt;img src=&quot;./assets/rve-android/as-setup-debugger-02.png&quot; alt=&quot;as setup debugger02&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;电脑连接手机，AS点击菜单 &lt;code class=&quot;highlighter-rouge&quot;&gt;Attach Debugger to Android Process&lt;/code&gt;，弹出以下窗口，选择要断点的进程：
&lt;img src=&quot;./assets/rve-android/as-setup-debugger-03.png&quot; alt=&quot;as setup debugger02&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;找到合适的代码行设置断点，程序执行到这一步时进程暂停：
&lt;img src=&quot;./assets/rve-android/as-setup-debugger-04.png&quot; alt=&quot;as setup debugger02&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，我们就可以在程序运行中查看变量实际的值了，方便我们分析逻辑。上面的由于代码由于做过混淆，所以变量名都是没有规律的&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000//reverse-engineering-android</link>
        <link href="http://localhost:4000/reverse-engineering-android"/>
        <guid isPermaLink="true">http://localhost:4000/reverse-engineering-android</guid>
      </item>
    
      <item>
        <title>逆向工程简述</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;从一个逆向小白的正向工程师转向逆向工程的学习之旅&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;本人入坑逆向也没有多久，文章重点探讨入门的一些基本要点，如有大佬翻牌，还望多指点。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文仅作为学习交流，请勿用作非法用途。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;什么是逆向？ 通俗来讲，逆向工程就是将机器才能够懂的机器代码（0101二进制代码）翻译成人能够读懂的代码（汇编、smali代码）。 但实际情况往往是，我们只寻找关键的代码去翻译或仅了解其业务逻辑，因为要将所有的机器代码翻译出来，工作量是极其巨大的且繁琐的。&lt;/p&gt;

&lt;p&gt;本人原本是做Android开发的，所以最早接触的是Android APK的逆向，在没有涉及到JNI代码的APK中，逆向也相对容易一些。 但是很多应用开发者会比较注重代码安全，一些关键代码使用JNI的方式实现，来增加逆向难度，但仅仅是增加了难度，并不能阻挡reverse engineer的脚步。&lt;/p&gt;

&lt;h2 id=&quot;汇编语言之于逆向工程&quot;&gt;汇编语言之于逆向工程&lt;/h2&gt;

&lt;p&gt;掌握汇编语言是学会逆向的充分必要条件，汇编语言基本上是最接近机器代码的编程语音了，基本上所有的逆向工具都是先将二进制文件反汇编成汇编代码，供给逆向工程师分析（Java语言也是类似，可以认为smali代码是面向JVM的机器代码）。&lt;/p&gt;

&lt;p&gt;在分析汇编语言时，会比较枯燥，我们往往不需要一行一行的仔细去分析，只需要关注一些关键的代码即可，理出代码片段的大致思路然后再着重分析关键代码即可； 也可以借助工具（如IDA Pro，Hopper Disassembler），将汇编代码转换成C的伪代码，这样分析起来效率会更高。&lt;/p&gt;

&lt;h2 id=&quot;逆向工具&quot;&gt;逆向工具&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;IDA Pro：逆向工程师的灵魂，功能强大，自行体会。&lt;/li&gt;
  &lt;li&gt;Hopper Disassembler：功能和IDA类似，不如IDA强大，但价格比IDA便宜太多，对objective-c支持更友好。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ibotpeaches.github.io/Apktool/&quot;&gt;apktool&lt;/a&gt;：Android APK反编译工具。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/DexPatcher/dex2jar&quot;&gt;dex2jar&lt;/a&gt;：dex文件转jar工具。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://java-decompiler.github.io/&quot;&gt;JD-GUI&lt;/a&gt;：直接jar反编译成Java代码浏览。&lt;/li&gt;
  &lt;li&gt;Android Studio：smali代码浏览，Android APK断点debug。&lt;/li&gt;
  &lt;li&gt;Charles/Flidder、Wireshark：网络抓包工具。&lt;/li&gt;
  &lt;li&gt;UltraEdit: 查看、修改二进制文件等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;逆向的分类&quot;&gt;逆向的分类&lt;/h2&gt;

&lt;p&gt;逆向工程按照编程语言类别，可以分为:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解释型语言的逆向(如Android APP)&lt;/li&gt;
  &lt;li&gt;编译型语言的逆向(如C/C++、Objective-C)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;解释型语言&lt;/code&gt;(如Java)的运行环境是JVM之类的虚拟机，其反编译的难度通常较低。以Java语言为例，编译器编译的结果通常是&lt;em&gt;.class&lt;/em&gt;或者&lt;em&gt;.dex&lt;/em&gt;文件，在没有做代码混淆的情况下，很容易反汇编出Java源码，分析出代码逻辑。而且混淆也只是将类、方法、变量名称替换成&lt;em&gt;a&lt;/em&gt; &lt;em&gt;b&lt;/em&gt; &lt;em&gt;c&lt;/em&gt; &lt;em&gt;d&lt;/em&gt;这种没有任何意义的名字，增加理解难度而已。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;编译型语言&lt;/code&gt;(如C/C++，Objective-C等)最终编译出来的机器代码就比较复杂，因为其机器代码是跟CPU架构相关的，因此针对不同的CPU架构编译出来的二进制文件是不同的，反汇编得到的代码也会不一样。往往需要针对特定的CPU架构去解读汇编语言，才能正确的分析出结果出来，这就需要对不同架构CPU的寄存器、寻址方式等特性有所了解才行。另外二进制文件反汇编出来的函数、变量名通常是机器生成的无意义字符串，所以分析难度通常相较于解释型语言会更大一些。&lt;/p&gt;

&lt;h2 id=&quot;分析手段&quot;&gt;分析手段&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;常用的分析手段有以下三种：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;静态分析&lt;/li&gt;
  &lt;li&gt;动态分析&lt;/li&gt;
  &lt;li&gt;网络流量分析&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在做逆向的时候，通常需要根据需要被分析的程序特点，选择一种或者多种手段结合使用，来达到最佳效果。&lt;/p&gt;

&lt;h3 id=&quot;静态分析&quot;&gt;静态分析&lt;/h3&gt;

&lt;p&gt;将机器代码反汇编成方便人类理解的代码，如smali代码（Java）、汇编代码或汇编代码翻译的C语言伪代码等等，通过分析这些比较低级的编程语言的代码，找到程序的业务流程或设计逻辑。&lt;/p&gt;

&lt;h3 id=&quot;动态分析&quot;&gt;动态分析&lt;/h3&gt;

&lt;p&gt;通过断点调试手段，让程序单步执行进行分析。动态分析往往是在静态分析出一定的结果的基础上进行，找到合适的地方给代码打断点，即时地读取当前变量的值，来进一步分析程序的逻辑、获取程序关系数据。&lt;/p&gt;

&lt;h3 id=&quot;网络流量分析&quot;&gt;网络流量分析&lt;/h3&gt;

&lt;p&gt;通过代理方式或者其他方式，截取程序与服务器通信的数据流量（抓包），来分析客户端和服务端的通信协议。网络流量分析比较有局限性，若客户端使用&lt;em&gt;Http&lt;/em&gt;这种明文传输的协议，会比较容易分析；但如果客户端使用SSL、&lt;em&gt;Https&lt;/em&gt;等加密传输协议与服务端进行通信，那么抓包的前提是需要拿到服务端下发给客户端的证书才能进一步解密分析，这种情况下就比较棘手。网上有方案通过安装插件拿到Chrome或者Firefox浏览器的本地证书，但只适用于客户端是网页的情况。若其他大佬有好的宝贵经验，还望能指点迷津。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;详细章节&quot;&gt;详细章节&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;reverse-engineering-android&quot;&gt;Java语言的逆向(Android APP)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;reverse-engineering-asm&quot;&gt;汇编语言简述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;reverse-engineering-oc&quot;&gt;Objective-C语言的逆向&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;reverse-engineering-c_cxx&quot;&gt;C/C++二进制逆向&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 27 Jan 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000//reverse-engineering-summary</link>
        <link href="http://localhost:4000/reverse-engineering-summary"/>
        <guid isPermaLink="true">http://localhost:4000/reverse-engineering-summary</guid>
      </item>
    
  </channel>
</rss>
