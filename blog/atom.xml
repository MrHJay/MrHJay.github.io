<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coder Jay's Blog</title>
    <description>Coder Jay's persional tech blog</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <author>
      <name>Coder Jay</name>
      <email>hejiedhj@.163.com</email>
      <uri>https://jay-dh.github.io/</uri>
    </author>
    
      <item>
        <title>Objective-C语言的逆向(Mac OS)</title>
        <description>&lt;p&gt;逆向分析Objective-C程序时，就需要用到IDA Pro和Hopper Disassembler等工具来帮助我们分析了。IDA Pro功能强大，插件丰富，可以为逆向分析提供许多便利；Hopper Disassembler对于反汇编Objective-C有其优势，动态调试十分方便。通常可以两个工具同时使用。下面以Mac版本的QQ音乐为例，初探一下Objective-C的逆向分析流程。&lt;/p&gt;

&lt;h2 id=&quot;静态分析&quot;&gt;静态分析&lt;/h2&gt;

&lt;h3 id=&quot;使用ida-pro分析&quot;&gt;使用IDA Pro分析&lt;/h3&gt;

&lt;p&gt;首先打开IDA64.app（Mac版的QQ音乐是64位版本，所以这里使用的是IDA64），点击菜单File –&amp;gt; Open，找到QQ音乐所在目录选中：
&lt;img src=&quot;./assets/rve-oc/ida-open-app.png&quot; alt=&quot;open App&quot; /&gt;
可以看到，QQ音乐.app并不是一个文件，而是一个特殊的文件夹，依次选择Contents –&amp;gt; MacOs –&amp;gt; QQMusic(可执行二进制文件)，并点击Open打开QQMusic。打开后IDA会解析二进制文件，解析过程比较长，需耐心等待（解析完成后可以Ctrl+S保存解析结果，保存为后缀&lt;code class=&quot;highlighter-rouge&quot;&gt;.ida&lt;/code&gt;的文件，下次可以直接用IDA打开）。
&lt;img src=&quot;./assets/rve-oc/ida-qq-music-main.png&quot; alt=&quot;QQMusic main&quot; /&gt;
IDA左边Function Window列出了解析出来的的所有函数列表，需要注意的是，OC反编译出来后，并没有以&lt;code class=&quot;highlighter-rouge&quot;&gt;类&lt;/code&gt;来划分函数，因为所有的类都被打包在同一个文件里，但是IDA反编译的函数是以&lt;code class=&quot;highlighter-rouge&quot;&gt;-[类名 函数名]&lt;/code&gt;这样的规律来命名。&lt;/p&gt;

&lt;p&gt;这里，我们可以看出，计算机并不知道什么是类、什么是面向对象，暂且可以这样说，对于计算机而言只有&lt;strong&gt;一段段&lt;/strong&gt;的可执行代码 – 即函数。（这里说是「暂且」，是因为我们后续深入研究汇编代码时就会发现，计算机其实也不认识函数O_o，计算机只认识&lt;strong&gt;一句句&lt;/strong&gt;可执行指令。函数、类只是方便人们组织代码的架构，所创造的代码规范，而这个规范的很多工作是编译器自动为我们完成的）&lt;/p&gt;

&lt;p&gt;然后我选择&lt;code class=&quot;highlighter-rouge&quot;&gt;_main&lt;/code&gt;函数，并双击打开，就是左边的汇编代码内容了，可能小白（包括我）第一次看到这个代码会有点懵。不要怕，问题不大～，我们输入&lt;code class=&quot;highlighter-rouge&quot;&gt;F5&lt;/code&gt;，强大的IDA就会为我们生产C的伪代码：
&lt;img src=&quot;./assets/rve-oc/ida-qq-music-main-c.png&quot; alt=&quot;QQMusic main C&quot; /&gt;
这样是不是就有种似曾相识的感觉了？◉‿◉&lt;/p&gt;

&lt;p&gt;熟悉OC的朋友看到NSApplicationMain这个函数应该很清楚，这里其实就是OC框架下的程序入口。但是传入的参数可能会让人疑惑，我们可以和汇编代码比较起来看，然后就会明白，这只是IDA翻译成伪代码时的优化问题，&lt;code class=&quot;highlighter-rouge&quot;&gt;v3&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;v4&lt;/code&gt;其实就是参数&lt;code class=&quot;highlighter-rouge&quot;&gt;argc&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;argv&lt;/code&gt;。所以伪代码在逆向分析中仅供参考，用于快速的分析代码流程逻辑非常有帮助，但是到实际的调试阶段，还是需要以汇编代码为准。&lt;/p&gt;

&lt;p&gt;滑动函数列表，我们可以看到QQ音乐代码中所有的函数，通过函数名称可以看出程序中类的划分、命名等。通过这些信息可以大致猜到这些类大概是干嘛用的。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;QQMusicMainPlayerController&lt;/code&gt; 这个类应该是QQ音乐主播放器View（MVC结构）对应的Controller，类里的函数包括了一系列的UI事件处理，如收藏歌曲、下载事件处理、显示歌手详情等（不要问我怎么知道的～我也都是盲猜的）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/ida-qq-music-fun-list.png&quot; alt=&quot;QQMusic function list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中展示了&lt;code class=&quot;highlighter-rouge&quot;&gt;QQMusicMainPlayerController downloadClickActionAtRow&lt;/code&gt;这个函数的代码内容，代码中可以看到很多&lt;code class=&quot;highlighter-rouge&quot;&gt;_objc_msgSend&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_storeStrong&lt;/code&gt;等函数调用，这其实是OC的消息机制导致的。在OC中，所有的函数调用都被转换成给这个对象发消息(即 &lt;code class=&quot;highlighter-rouge&quot;&gt;_objc_msgSend&lt;/code&gt;)，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_storeStrong&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/code&gt;则是OC内存回收机制相关的函数调用。这些函数都是编译器在编译代码时自动生成的代码，感兴趣可以自行深入了解一下OC的消息机制和几种内存回收原理。&lt;/p&gt;

&lt;p&gt;简单分析(盲猜)一下代码的大致流程：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__cdecl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QQMusicMainPlayerController&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;downloadClickActionAtRow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QQMusicMainPlayerController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ST40_8&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ST38_8&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ST30_8&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ST28_8&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ST20_8&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ST10_8&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ST08_8&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [rsp+48h] [rbp-48h]&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__int64&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [rsp+50h] [rbp-40h]&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [rsp+68h] [rbp-28h]&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__int64&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [rsp+70h] [rbp-20h]&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [rsp+7Ch] [rbp-14h]&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SEL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [rsp+80h] [rbp-10h]&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;QQMusicMainPlayerController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [rsp+88h] [rbp-8h]&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;v17&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v15&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v14&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0LL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;objc_storeStrong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 1. 向ListTagManager拿到shareListTagManager对象 v5&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OBJC_CLASS___ListTagManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;shareListTagManager&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 2. 再通过getListByTag得到歌曲的listData，即v13&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;getListByTag:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1LL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;listData&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v13&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;_objc_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;_objc_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 3. 再通过objectAtIndex得到这一首歌曲的对应的数据对象，即v12&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;objectAtIndex:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 4. 创建一个DownloadQualityMenu对象并初始化得到v11&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OBJC_CLASS___DownloadQualityMenu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;alloc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v11&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;init&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 5. 调用showMenuWithEvent函数，并传入v12显示下载菜单&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;_objc_msgSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;showMenuWithEvent:SongInfo:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;objc_storeStrong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0LL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;objc_storeStrong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0LL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;objc_storeStrong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0LL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;objc_storeStrong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0LL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;向 &lt;code class=&quot;highlighter-rouge&quot;&gt;ListTagManager&lt;/code&gt;拿到 &lt;code class=&quot;highlighter-rouge&quot;&gt;shareListTagManager&lt;/code&gt;对象，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;v5&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;再通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;getListByTag&lt;/code&gt;得到歌曲的 &lt;code class=&quot;highlighter-rouge&quot;&gt;listData&lt;/code&gt;，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;v13&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;再通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;objectAtIndex&lt;/code&gt;得到这一首歌曲的对应的数据对象，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;v12&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;DownloadQualityMenu&lt;/code&gt;对象并初始化得到 &lt;code class=&quot;highlighter-rouge&quot;&gt;v11&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;v11&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;showMenuWithEvent&lt;/code&gt;函数，并传入 &lt;code class=&quot;highlighter-rouge&quot;&gt;v12&lt;/code&gt;显示下载菜单&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以看到，以上的代码逻辑都是根据现有伪代码信息猜的。可能你会疑惑，这么玄学吗？？你都是怎么猜出来的。没错，都是凭直觉猜的… 正如我在&lt;a href=&quot;reverse-engineering-summary&quot;&gt;逆向工程入门简述&lt;/a&gt;中提到的，猜逻辑的前提是具有一定的编程经验。可以说编程经验越丰富，猜的速度和猜中的几率也就更快更大。&lt;/p&gt;

&lt;h2 id=&quot;动态分析&quot;&gt;动态分析&lt;/h2&gt;

&lt;p&gt;前面介绍了如使用IDA静态分析OC程序，接下来说一下如何使用Hopper Disassembler动态调试OC程序。&lt;/p&gt;

&lt;p&gt;首先同样的用Hopper Disassembler打开QQ音乐APP，直接将QQ音乐.app拖入Hopper Disassembler即可。和IDA一样，新打开的app文件需要解析，这个过程比较耗时，需要耐心等待(解析完成后Ctrl+S另存文件，保存解析后的数据）。解析完成后可以看到，左边窗口同样是函数列表，右边窗口展示代码，顶部Tab可以切换汇编代码/视图/伪代码/16进制模式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-qq-music-main.png&quot; alt=&quot;QQMusic main&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然要动态调试代码，我们就找一些代码试试水，比如试着获取歌曲相关信息的下载地址。我们在函数列表区域搜索框中输入关键字 &lt;code class=&quot;highlighter-rouge&quot;&gt;download&lt;/code&gt;，滚动函数列表，看看能搜到什么有用的信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-qq-music-download-search.png&quot; alt=&quot;hd download search&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看到&lt;code class=&quot;highlighter-rouge&quot;&gt;DownloadBasicInfo download_url&lt;/code&gt;这个比较可疑，于是下断点开始调试，菜单点击Debug –&amp;gt; Select Debugger&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-debugger-menu.png&quot; alt=&quot;hd debugger menu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;弹出对话框中点击Local Debugger，弹出调试对话框&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-local-debugger-dialog.png&quot; alt=&quot;hd local debugger dialog&quot; height=&quot;80%&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先运行QQ音乐.app，然后回到Hopper Disassembler点击调试对话框中的Attach to Process，找到QQ音乐的进程，双击选中&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-debugger-select-process.png&quot; alt=&quot;hd debugger select process&quot; height=&quot;60%&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时，程序会断点在一个特定的地址，&lt;code class=&quot;highlighter-rouge&quot;&gt;continue execution&lt;/code&gt;按钮直接跳过即可，然后就可以愉快的调试啦&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-local-debugger-begin.png&quot; alt=&quot;hd debugger begin&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回到QQ音乐，随便点一个歌单，点击播放&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-qq-music-list-preview.png&quot; alt=&quot;QQMusic list preivew&quot; height=&quot;80%&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时断点生效，程序停在0x000000010024b5a7这一地址&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-debugger-breakpoint-active.png&quot; alt=&quot;hd breakpoint active&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看RAX寄存器地址（点击寄存器左边小箭头），查看内存数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-debugger-breakpoint-val.png&quot; alt=&quot;hd breakpoint val 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，url的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;http://y.gtimg.cn/music/photo_new/T002R300x300M000000gpcQK4XrHUF.jpg&lt;/code&gt;，浏览器输入查看结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-debugger-url-val-1.png&quot; alt=&quot;hd debug URL value&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正好是歌曲的封面图片数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-qq-music-song-info-1.png&quot; alt=&quot;QQMusic song info&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里需要注意的是，断点查看RAX寄存器地址的内存值时，前16字节我们是直接跳过的，第17个字节是字符串的长度，第18个字节开始才是URL的值。这是由NSString的数据结构决定的，感兴趣的可以深入了解一下。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;换一首歌再试试看，点击 &lt;code class=&quot;highlighter-rouge&quot;&gt;continue execution&lt;/code&gt;，QQ音乐点击下一首歌曲，再次断点查看内存值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://y.gtimg.cn/music/photo_new/T002R300x300M000004WkGkE30RCep.jpg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-debugger-breakpoint-val-2.png&quot; alt=&quot;hd breakpoint val 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;浏览器输入URL，再次验证得到的URL为歌曲封面图片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-oc/hd-debugger-url-val-2.png&quot; alt=&quot;hd debug URL value 2&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;逆向就这么容易吗&quot;&gt;逆向就这么容易吗&lt;/h3&gt;

&lt;p&gt;实则不然，&lt;code class=&quot;highlighter-rouge&quot;&gt;DownloadBasicInfo download_url&lt;/code&gt;这个函数其实是我试了若干次其他可疑函数才命中的，而且一开始我其实是想找歌曲的下载地址，但是后面发现找到下载URL地址后，浏览器输入后返回403，说明还有其他参数需要加入（猜测是header、token等鉴权参数，服务器安全机制的常规操作）。难度太大就选了这个软柿子捏了，方便初学者入门，&lt;/p&gt;

&lt;p&gt;实际逆向过程也是如此，二进制的可执行文件是面向机器的，它并不是按照人的习惯的规则去整理代码，因此我们往往需要花大量的精力猜测、尝试，才能找到自己关心的那段关键代码。&lt;/p&gt;

&lt;p&gt;但是，相较于C/C++、Java等可混淆的语言而言，使用消息机制的OC的逆向分析还是要简单的多，函数名的字符串基本都是源码保持一致，这样猜测代码逻辑起来会容易很多，在&lt;a href=&quot;reverse-engineering-android&quot;&gt;Java语言的逆向(Android APP)&lt;/a&gt;章节中分析混淆后的Java代码，基本上就得靠动态调试来猜逻辑了。&lt;/p&gt;

&lt;h2 id=&quot;快捷键&quot;&gt;快捷键&lt;/h2&gt;

&lt;h3 id=&quot;ida-常用快捷键&quot;&gt;IDA 常用快捷键&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;函数列表&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+F&lt;/code&gt;：输入关键字查找&lt;/li&gt;
  &lt;li&gt;IDA View中，&lt;code class=&quot;highlighter-rouge&quot;&gt;F5&lt;/code&gt;：反编译汇编代码为伪代码&lt;/li&gt;
  &lt;li&gt;IDA View中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Tab&lt;/code&gt;：转跳到当前行对应的伪代码&lt;/li&gt;
  &lt;li&gt;IDA View中，&lt;code class=&quot;highlighter-rouge&quot;&gt;G&lt;/code&gt;：转跳地址&lt;/li&gt;
  &lt;li&gt;IDA View中，&lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;：添加注释&lt;/li&gt;
  &lt;li&gt;伪代码View中，&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;：添加注释&lt;/li&gt;
  &lt;li&gt;光标停在函数名中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Enter&lt;/code&gt;：进入函数实现的代码，ESC返回上一层转跳位置&lt;/li&gt;
  &lt;li&gt;光标停在函数名中，&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;：查看函数引用&lt;/li&gt;
  &lt;li&gt;光标停在变量名，&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;：变量重命名&lt;/li&gt;
  &lt;li&gt;光标停在变量名，&lt;code class=&quot;highlighter-rouge&quot;&gt;Y&lt;/code&gt;：修改变量申明类型&lt;/li&gt;
  &lt;li&gt;Structures View中，&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;：创建结构体&lt;/li&gt;
  &lt;li&gt;光标在结构体ends这一行，&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;：添加成员&lt;/li&gt;
  &lt;li&gt;光标在结构体成员这一行，&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;：改变成员字段大小(db, dw, dd, dq分别代表1-8个字节)&lt;/li&gt;
  &lt;li&gt;光标在结构体成员这一行，&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;：成员变量重命名&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
        <link>//reverse-engineering-oc</link>
        <link href="/reverse-engineering-oc"/>
        <guid isPermaLink="true">/reverse-engineering-oc</guid>
      </item>
    
      <item>
        <title>汇编语言简述(逆向工程)</title>
        <description>&lt;p&gt;在逆向分析C/C++等编译型语言时，分析汇编代码是必不可少的。因此，掌握一些简单汇编的知识是十分有必要的。&lt;/p&gt;

&lt;h2 id=&quot;一些基本概念&quot;&gt;一些基本概念&lt;/h2&gt;

&lt;p&gt;汇编语音是面向机器的程序设计语音，使用助记符代替操作CPU指令的机器码，所以汇编语言也称之为符号语言。 不同于C/C++、Java等高级语言，汇编语言操作的对象是CPU、寄存器、内存。 通俗来讲，在汇编语言的里，执行一个指令的一般流程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将需要操作的内容写入寄存器&lt;/li&gt;
  &lt;li&gt;执行对应的机器指令，让CPU运算结果&lt;/li&gt;
  &lt;li&gt;从寄存器读取结果的值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;寄存器&quot;&gt;寄存器&lt;/h3&gt;

&lt;p&gt;要了解汇编，首先需要知道，什么是寄存器。 寄存器是CPU里的高速缓冲区，学过计算机原理的同学应该都知道，CPU的运算速度是极快的，而内存的读写速度远远跟不上CPU的运算速度的，根据木桶定律，计算机的整体效率受限于内存的读写速度。因此，为了提高效率，人们想到在CPU和内存之间增加一个高速缓存（很多CPU还分一级缓存、二级缓存甚至是三级缓存）。 高速缓存的读写速度比内存快得多，而高速缓存的作用就是预先将内存中需要运算的数据写入高速缓存中，等到CPU可以执行机器指令的时候，就可以直接从速度较快的高速缓存中读取，而不是从读写代价较高的内存中读，从而，提高了计算机的整体运行效率。&lt;/p&gt;

&lt;p&gt;因此，在编写汇编代码的时候，需要先将数据写入到寄存器中，CPU才能做进一步的操作，而寄存器又分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通用寄存器&lt;/li&gt;
  &lt;li&gt;指针和变址寄存器，指针寄存器又分为：基址指针寄存器、堆栈指针寄存器等&lt;/li&gt;
  &lt;li&gt;段寄存器&lt;/li&gt;
  &lt;li&gt;指令指针寄存器（PC）&lt;/li&gt;
  &lt;li&gt;标志寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在做逆向分析过程中，关注最多的一般是通用寄存器、堆栈指针寄存器、标志寄存器等，下文会详细说明。&lt;/p&gt;

&lt;h3 id=&quot;大端小端&quot;&gt;大端小端&lt;/h3&gt;

&lt;p&gt;做逆向分析的时候，经常需要通过动态分析手段来读取内存中的数据，将内存中的数据对应到代码中的变量上，值得一提的是，内存中数据存储的顺序是需要我们注意的。我们都知道，计算机里存储数据的最小单位是byte，即字节，内存也不例外。我们逆向分析得到的内存数据是以字节为单位的数据。一个字节是8-bit（位），而代码中的基本数据类型有8-bit、16-bit、32-bit、64-bit等等，这些长度大于一个byte的数据类型在内存中是以怎样的顺序进行存储的呢？这就涉及到大小端模式的问题了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。&lt;/li&gt;
  &lt;li&gt;小端模式：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以32位的整形数据为例，字节的排列顺序如下：
&lt;img src=&quot;./assets/rve-asm/memory-endian-struct.jpg&quot; alt=&quot;arm cprs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PowerPC架构的CPU中一般是大端模式，x86、arm架构的CPU普遍采用小端模式。&lt;/p&gt;

&lt;h3 id=&quot;栈和堆&quot;&gt;栈和堆&lt;/h3&gt;

&lt;p&gt;栈和堆是学汇编需要了解的两个概念，栈和堆是汇编使用内存时的两种划分，它们都是内存上的存储数据的空间。&lt;/p&gt;

&lt;p&gt;栈：大家都知道，栈是一种数据结构，数据按照先进后出的方式进行存储，汇编里也是如此，但一般只用于保存函数内的局部变量。在调用一个函数的时候，先预留足够数量的栈空间，供函数内部使用，在函数结束时，又需要移动栈指针空间，使之与进入函数前的地址保持一致，即所谓的&lt;code class=&quot;highlighter-rouge&quot;&gt;栈平衡&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;堆：堆也是用于存放变量的，但不同于栈但是，栈用于保存申明方式定义的局部变量，而堆用于保存&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;方式申请的变量。由于是运行时才使用内存空间，就导致编译器无法知道你需要多大的空间，所以在C/C++里这种方式申请的内存需要自己手动释放。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-asm/asm-stack-heap.jpg&quot; alt=&quot;stack heap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，堆内存是从低地址往高地址使用内存空间的，而栈是从高地址往低地址使用内存空间。这就是为什么我们经常看到函数的开头会有一句 &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB SP 0x20&lt;/code&gt;这种移动SP指针下移的代码，哦！原来是在准备栈空间给函数内部的局部变量使用；而在函数末尾又会&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD SP 0x20&lt;/code&gt;去还原栈指针，保持栈平衡。&lt;/p&gt;

&lt;p&gt;这里大家可以思考一下，我们写递归函数时，如果遇到死循环抛出异常，为什么叫StackOverflow异常？就是因为死循环调用函数时，会一直移动SP下移，最终栈内存会和堆内存相遇，这时候就是我们遇到的栈内存溢出异常了。&lt;/p&gt;

&lt;h3 id=&quot;汇编语言的特点&quot;&gt;汇编语言的特点&lt;/h3&gt;

&lt;p&gt;由于汇编是最接近机器代码的程序设计语言，因此有很多特性不同于我们熟悉的高级语言：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;没有申请、释放内存的概念，对内存操作没有限制，拿到内存地址就读写。不同于C/C++等语言里，局部变量的内存的分配和释放都是编译器在编译的时候完成的。&lt;/li&gt;
  &lt;li&gt;没有函数、方法等概念，高级语言中所有的函数、方法对应到汇编语言中都是一个个代码片段。而在汇编里实现高级语言的函数调用是：
    &lt;ul&gt;
      &lt;li&gt;保存当前代码地址的下一个指令地址 &lt;code class=&quot;highlighter-rouge&quot;&gt;addr_a&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;转跳到代码片段 &lt;code class=&quot;highlighter-rouge&quot;&gt;fun_a&lt;/code&gt;的地址 &lt;code class=&quot;highlighter-rouge&quot;&gt;addr_b&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;代码片段 &lt;code class=&quot;highlighter-rouge&quot;&gt;fun_a&lt;/code&gt;执行完后，转跳到地址 &lt;code class=&quot;highlighter-rouge&quot;&gt;addr_a&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上，在自己实战积累后，会有更深入的理解和感悟。&lt;/p&gt;

&lt;h3 id=&quot;cpu的分类&quot;&gt;CPU的分类&lt;/h3&gt;

&lt;p&gt;由上面的描述的内容可知，汇编语言操作的对象是CPU、是硬件，但CPU的架构分多种，常见的架构有 &lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ARM&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;MIPS&lt;/code&gt;等。个人计算机主要以 &lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;系列架构为主；手机、平板等移动设备则以 &lt;code class=&quot;highlighter-rouge&quot;&gt;ARM&lt;/code&gt;系列架构为主，下文将围绕这两种架构来分别描述汇编语言。&lt;/p&gt;

&lt;h2 id=&quot;arm汇编&quot;&gt;ARM汇编&lt;/h2&gt;

&lt;p&gt;ARM架构又分为32位架构和64位架构，目前市面上的手机基本都是64位的，而64位是向下兼容32位的。大部分应用开发商（特别是Android）在使用C/C++混合编码时，为了兼容旧设备，在编译时都会保留32位的编译选项，所以本文将以32位的ARM为例来分析汇编。&lt;/p&gt;

&lt;h3 id=&quot;arm寄存器&quot;&gt;ARM寄存器&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;#&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;别名&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;用途&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一般存放系统调用号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R8&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R9&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R11&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;栈帧指针寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R12&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;IP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;程序内部调用寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R13&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;栈指针寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R14&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;程序链接寄存器，一般存放函数的返回地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R15&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;PC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;程序计数寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CPSR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;状态寄存器&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在函数调用中，参数通用寄存器R0 ～ R3传递，超过4个的参数剩余参数，压入栈中，通过栈传参，函数的返回值存入R0寄存器中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPSR&lt;/strong&gt;（Current Program Status Register）：当前程序状态寄存器，用于存放上一次指令执行的状态，按位表示状态，即每一位表示了不同的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-asm/arm-cpsr-info.jpg&quot; alt=&quot;arm cprs&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPSR的低8位称为控制位，程序无法修改（除非CPU处于特权模式）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt; 为条件码标志位，它们的值受逻辑运算或算术运算的结果而改变。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Bits&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Flag&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Desciption&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[31]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;N(Negative)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;指令执行结果为负数时置1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[30]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Z(Zero)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;指令执行结果为0时置1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[29]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;C(Carry)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对于加法有进位则置1，对于减法有借位则置0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[28]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;V(Overflow)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;指令结果不能用32位的二进制补码存储，即发生了溢出时置1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[24]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;J(Jazelle)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;允许ARM处理器去以硬件执行java字节码的状态标志&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[9]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;E(Endian)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小端序置0，大端序置1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[5]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;T(Thumb)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当为Thumb模式时置1，ARM模式置0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[4:0]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;M(Mode)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当前的权限模式（用户态，内核态）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;常见指令&quot;&gt;常见指令&lt;/h3&gt;

&lt;p&gt;在做逆向分析阅读汇编代码时，我们不需要详细理解每一句汇编代码的作用，很多时候都是跳跃式的阅读，掌握关键的汇编代码逻辑即可。汇编的指令比较多，我们也并不需要全部记住，掌握一些常见的指令就能理解大部分的汇编代码，遇到其他不常用指令实在是需要理解，再去查找手册就行了。&lt;/p&gt;

&lt;p&gt;下面列举一些常见的汇编指令：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Name&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Name&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MOV&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;移动数据&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;EOR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;异或运算&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ADD&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;加法运算&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LDR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;加载数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SUB&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;减法运算&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;存储数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MUL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;乘法运算&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LDM&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;多次加载数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LSL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑左移&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;STM&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;多次存储数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LSR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑右移&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;PUSH&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据入栈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ASR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;算术右移&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;POP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据出栈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ROR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;循环右移&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;分支转跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CMP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据比较&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;链接(保存当前地址用于返回)分支转跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;AND&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;与运算&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BX&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;分支转跳切换(条件切换Thumb模式)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ORR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;或运算&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BLX&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;链接分支转跳切换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;实战分析&quot;&gt;实战分析&lt;/h3&gt;

&lt;p&gt;下面我们来分析一小段简单的汇编代码。&lt;/p&gt;

&lt;h4 id=&quot;c语言源码&quot;&gt;C语言源码&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fun_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个简单的加法函数&lt;code class=&quot;highlighter-rouge&quot;&gt;fun_A&lt;/code&gt;，通过IDA反汇编得到对应的汇编代码&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;var_14&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;var_10&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;var_C&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xC&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;var_8&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;var_4&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;; __unwind {&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SUB&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;; 申请栈空间，20 byte&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;MOV&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R1&lt;/span&gt;                  &lt;span class=&quot;c&quot;&gt;; 参数b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;MOV&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;                  &lt;span class=&quot;c&quot;&gt;; 参数a&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;STR&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var_4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; 保存a到栈&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;STR&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var_8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; 保存b到栈&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LDR&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var_4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; 读取a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LDR&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var_8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; 读取b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R1&lt;/span&gt;                  &lt;span class=&quot;c&quot;&gt;; a + b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;STR&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var_C&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; 结果c保存到栈&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LDR&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var_C&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; 读取c&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;STR&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var_10&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;STR&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;R3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var_14&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;; 还原栈空间&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BX&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;LR&lt;/span&gt;                      &lt;span class=&quot;c&quot;&gt;; 返回到调用地址&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，一段C代码被编译器汇编之后得到到汇编代码，代码可划分为以下几个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;申请栈空间&lt;/li&gt;
  &lt;li&gt;保存参数到栈中&lt;/li&gt;
  &lt;li&gt;真正关键的代码逻辑&lt;/li&gt;
  &lt;li&gt;恢复栈空间，保持栈平衡&lt;/li&gt;
  &lt;li&gt;返回&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此我们在看到一段函数代码的时候，开头的申请栈空间、保存参数以及末尾的恢复栈空间、返回的代码可以直接跳过，直接分析中间的逻辑代码。另外可以看到，由编译器编译得到的汇编代码会有很多冗余的部分，毕竟是机器翻译，逆向分析的时候不用太过深究，直接跳过即可。&lt;/p&gt;

&lt;h2 id=&quot;x86汇编&quot;&gt;x86汇编&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;x86与ARM汇编相比，语法上稍微有些不同，但分析汇编的代码思路都是一致的，这里介绍一下x86汇编的基本要点和硬件上的不同之处。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;x86架构也分32位架构和64位架构，目前市面上的个人电脑普遍是64位，向下兼容32位，下面以64位的x86_64为例分析。&lt;/p&gt;

&lt;h3 id=&quot;x86_64寄存器&quot;&gt;x86_64寄存器&lt;/h3&gt;

&lt;h4 id=&quot;16个通用寄存器&quot;&gt;16个通用寄存器&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;#&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;用途&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;#&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;用途&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RAX&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通常作为函数返回值&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R8&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通常用作参数5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RBX&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;被调用者保护的寄存器，或用作基指针&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R9&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通常用作参数6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RCX&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通常用作参数4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;临时寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RDX&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通常用作参数3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R11&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;临时寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RSI&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通常用作参数2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R12&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;临时寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RDI&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;通常用作参数1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R13&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;临时寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RBP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;被调用者保护的寄存器，或用作帧指针&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R14&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;临时寄存器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RSP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;栈指针寄存器，指向栈顶&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;R15&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;临时寄存器&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;通用寄存器还经常可以看到只使用32位、16位、高8位、低8位的用法，但仅限于 &lt;code class=&quot;highlighter-rouge&quot;&gt;RAX&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;RBX&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;RCX&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;RDX&lt;/code&gt;这几个寄存器。以RAX寄存器为例，对应用法的数据结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./assets/rve-asm/x86_64-register-compat.jpg&quot; alt=&quot;x86_64 register compat&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;eflags状态寄存器&quot;&gt;EFLAGS(状态寄存器)&lt;/h4&gt;

&lt;p&gt;x86及x86_64同样也有自己的状态寄存器，存放当前的程序状态标志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;状态标志位&lt;/strong&gt;：用于指示算术指令（如&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;MUL&lt;/code&gt;等）的运算结果&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Bits&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Flag&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Desciption&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[0]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CF(Carry Flag)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对于算术运算有进位或借位则置1，反之则置0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[2]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;PF(Partiy Flag)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;运算结果最低有效字节包含偶数个1则置1，反之则置0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[4]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;AF(Adjust Flag)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[6]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ZF(Zero Flag)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;运算结果为0则置1，反之置0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[7]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SF(Sign Flag)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;运算结果为正则置0，负数置1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[11]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;OF(Overflow Flag)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;结果是较大的正数或较小的负数，并且无法匹配目的操作数（即结果溢出）时将该位置1，反之则置0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;控制标志位&lt;/strong&gt;：控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分别用于设置以及清除DF标志。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Bits&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Flag&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Desciption&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[10]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DF(Direction Flag)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;置1时串指令自动递减（从高地址向低地址方向处理字符串），置0时则使得串指令自动递增&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;16个向量寄存器&quot;&gt;16个向量寄存器&lt;/h4&gt;

&lt;p&gt;用于向量运算&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;#&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;用途&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;XMM0-XMM1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用来传递和返回浮点参数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;XMM2-XMM7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用来传递浮点参数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;XMM8-XMM15&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;临时寄存器&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;常用指令&quot;&gt;常用指令&lt;/h3&gt;

&lt;p&gt;与ARM汇编类似，这里列举一些常见的指令，用于基本的逆向分析：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Name&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Name&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MOV&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;移动数据&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;INTO&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;溢出中断指令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;PUSH&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据入栈&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SHL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑左移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;POP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据出栈&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SHR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑右移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ADD&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;加法运算&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SAL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;算术左移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SUB&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;减法运算&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SAR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;算术右移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;INC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;操作数加1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ROL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;循环左移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DEC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;操作数减1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ROR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;循环右移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ADC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;多字节加法，带进位(CF)做加法&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RCL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;带进位循环左移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SBB&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;多字节减法，带借位(CF)做减法&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RCR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;带进位循环右移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CMP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据比较，只改变标志寄存器&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LEA&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;取偏移地址指令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;AND&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑与&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JMP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;转移指令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;OR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑或&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;等于则转跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;XOR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑异或&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JNE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不等于则转跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;NOT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑非&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JG&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大于则转跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TEST&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;逻辑与运算类似，但只改变标记寄存器&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JGE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大于等于则转跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CALL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;子程序调用指令&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小于则转跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RET&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回指令&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;JLE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小于等于则转跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;INT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中断指令&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://azeria-labs.com/arm-data-types-and-registers-part-2&quot;&gt;Azeria Libs(ARM Data Types And Registers)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
        <link>//reverse-engineering-asm</link>
        <link href="/reverse-engineering-asm"/>
        <guid isPermaLink="true">/reverse-engineering-asm</guid>
      </item>
    
      <item>
        <title>Java语言的逆向(Android APP)</title>
        <description>&lt;p&gt;Java语言的逆向比较简单，只说一些关键思路和小技巧。下面以QQ音乐为例，讲述Android APP逆向的基本过程。&lt;/p&gt;

&lt;h2 id=&quot;静态分析&quot;&gt;静态分析&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;将APK反编译成比较方便理解的代码（如smali、Java代码等），进行静态分析，了解代码的流程和设计逻辑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;将apk反编译成smali代码&quot;&gt;将APK反编译成smali代码&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apktool d QQMusic72282.apk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;反编译出如下文件：
&lt;img src=&quot;./assets/rve-android/apk-smali.png&quot; alt=&quot;apk smali&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;将apk反编译成jar包&quot;&gt;将APK反编译成Jar包&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unzip &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; ./QQMusic72282-unzip QQMusic72282.apk &lt;span class=&quot;c&quot;&gt;# 解压APK&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ./QQMusic72282-unzip
d2j-dex2jar.sh classes.dex &lt;span class=&quot;c&quot;&gt;# dex转jar&lt;/span&gt;
d2j-dex2jar.sh classes2.dex
d2j-dex2jar.sh classes3.dex
d2j-dex2jar.sh classes4.dex
d2j-dex2jar.sh classes5.dex
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到jar包后直接用JD-GUI打开，即可查看Java代码了。&lt;/p&gt;

&lt;p&gt;但多个jar文件用JD-GUI查看很不方便，可以使用以下方法将多个jar合并成一个：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;tmp
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;tmp
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes-dex2jar.jar
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes2-dex2jar.jar
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes3-dex2jar.jar
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes4-dex2jar.jar
unzip &lt;span class=&quot;nt&quot;&gt;-uo&lt;/span&gt; ../classes5-dex2jar.jar

&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../
jar &lt;span class=&quot;nt&quot;&gt;-cvf&lt;/span&gt; classes-combined.jar &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; tmp &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用JD-GUI打开classes-combine.jar，可查看反编译的Java如下所示：
&lt;img src=&quot;./assets/rve-android/apk-to-jar-analysis.png&quot; alt=&quot;analysis jd-gui&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;动态分析&quot;&gt;动态分析&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过断点调试手段，来让APP可以断点单步执行，并通过实时读取变量的值来分析代码的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;准备工具&quot;&gt;准备工具&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;userdebug版&lt;/strong&gt;的Android手机。&lt;/li&gt;
  &lt;li&gt;Android Stuido + &lt;a href=&quot;https://github.com/JesusFreke/smali/wiki/smalidea&quot;&gt;smalidea插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么是userdebug版的？因为userdebug版的系统，所有的应用都是debuggable的，这样就可以通过Android Studio开启调试给应用打断点调试。网上也有其他手段，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;反编译APK在manifest.xml文件增加debuggable属性；&lt;/li&gt;
  &lt;li&gt;使用xposed框架，借助框架强制开启应用的debuggable属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但这些方案都有一些问题，方法1在修改了manifest.xml文件后，需要给apk重新打包签名，因此不适用于有签名验证的应用（如喜马拉雅APK重签名后安装，应用会抛签名不合法的异常）；方法2对于低版本Android可能适用，高版本的安卓（实测Android 7.0）已经行不通了。&lt;/p&gt;

&lt;h3 id=&quot;打开项目&quot;&gt;打开项目&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开Android Studio(确认安装好smalidea插件)&lt;/li&gt;
  &lt;li&gt;File –&amp;gt; Open –&amp;gt; 选择静态分析中反编译的smali源码目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;QQMusic72282\&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Mark smali及所有smali_classesx为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sources Root&lt;/code&gt;
&lt;img src=&quot;./assets/rve-android/as-setup-src.png&quot; alt=&quot;as setup src&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Run –&amp;gt; Edit Configurations –&amp;gt; 点击&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;Remote&lt;/code&gt;Configuration
&lt;img src=&quot;./assets/rve-android/as-setup-debugger-01.png&quot; alt=&quot;as setup debugger01&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;修改名字为QQMusic-Debugger，端口号设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;8700&lt;/code&gt;后点击&lt;code class=&quot;highlighter-rouge&quot;&gt;OK&lt;/code&gt;
&lt;img src=&quot;./assets/rve-android/as-setup-debugger-02.png&quot; alt=&quot;as setup debugger02&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;电脑连接手机，AS点击菜单 &lt;code class=&quot;highlighter-rouge&quot;&gt;Attach Debugger to Android Process&lt;/code&gt;，弹出以下窗口，选择要断点的进程：
&lt;img src=&quot;./assets/rve-android/as-setup-debugger-03.png&quot; alt=&quot;as setup debugger02&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;找到合适的代码行设置断点，程序执行到这一步时进程暂停：
&lt;img src=&quot;./assets/rve-android/as-setup-debugger-04.png&quot; alt=&quot;as setup debugger02&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，我们就可以在程序运行中查看变量实际的值了，方便我们分析逻辑。上面的由于代码由于做过混淆，所以变量名都是没有规律的&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
        <link>//reverse-engineering-android</link>
        <link href="/reverse-engineering-android"/>
        <guid isPermaLink="true">/reverse-engineering-android</guid>
      </item>
    
      <item>
        <title>逆向工程入门简述</title>
        <description>&lt;p&gt;从一个逆向小白的正向工程师转向逆向工程的学习之旅&lt;/p&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;在写这片文章时，本人入坑逆向也没有多久，作为小白，文章重点探讨小白入门的一些基本要点，如有大佬翻牌，还望多指点。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文仅作为学习交流，请勿用作非法用途。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;什么是逆向？ 通俗来讲，逆向工程就是将机器才能够懂的机器代码（0101二进制代码）翻译成人能够读懂的代码（汇编、smali代码）。 但实际情况往往是，我们只寻找关键的代码去翻译或仅了解其业务逻辑，因为要将所有的机器代码翻译出来，工作量是极其巨大的且繁琐的。&lt;/p&gt;

&lt;p&gt;本人原本是做Android开发的，所以最早接触的是Android APK的逆向，在没有涉及到JNI代码的APK中，逆向也相对容易一些。 但是很多应用开发者会比较注重代码安全，一些关键代码使用JNI的方式实现，来增加逆向难度，但仅仅是增加了难度，并不能阻挡reverse engineer的脚步。&lt;/p&gt;

&lt;h2 id=&quot;汇编语言之于逆向工程&quot;&gt;汇编语言之于逆向工程&lt;/h2&gt;

&lt;p&gt;掌握汇编语言是学会逆向的充分必要条件，汇编语言基本上是最接近机器代码的编程语音了，基本上所有的逆向工具都是先将二进制文件反汇编成汇编代码，供给逆向工程师分析（Java语言也是类似，可以认为smali代码是面向JVM的机器代码）。&lt;/p&gt;

&lt;p&gt;在分析汇编语言时，会比较枯燥，我们往往不需要一行一行的仔细去分析，只需要关注一些关键的代码即可，理出代码片段的大致思路然后再着重分析关键代码即可； 也可以借助工具（如IDA Pro，Hopper Disassembler），将汇编代码转换成C的伪代码，这样分析起来效率会更高。&lt;/p&gt;

&lt;h2 id=&quot;逆向工具&quot;&gt;逆向工具&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;IDA Pro：逆向工程师的灵魂，功能强大，自行体会。&lt;/li&gt;
  &lt;li&gt;Hopper Disassembler：功能和IDA类似，不如IDA强大，但价格比IDA便宜太多，对objective-c支持更友好。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ibotpeaches.github.io/Apktool/&quot;&gt;apktool&lt;/a&gt;：Android APK反编译工具。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/DexPatcher/dex2jar&quot;&gt;dex2jar&lt;/a&gt;：dex文件转jar工具。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://java-decompiler.github.io/&quot;&gt;JD-GUI&lt;/a&gt;：直接jar反编译成Java代码浏览。&lt;/li&gt;
  &lt;li&gt;Android Studio：smali代码浏览，Android APK断点debug。&lt;/li&gt;
  &lt;li&gt;Charles/Flidder、Wireshark：网络抓包工具。&lt;/li&gt;
  &lt;li&gt;UltraEdit: 查看、修改二进制文件等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;逆向的分类&quot;&gt;逆向的分类&lt;/h2&gt;

&lt;p&gt;逆向工程按照编程语言类别，可以分为:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解释型语言的逆向(如Android APP)&lt;/li&gt;
  &lt;li&gt;编译型语言的逆向(如C/C++、Objective-C)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;解释型语言&lt;/code&gt;(如Java)的运行环境是JVM之类的虚拟机，其反编译的难度通常较低。以Java语言为例，编译器编译的结果通常是&lt;em&gt;.class&lt;/em&gt;或者&lt;em&gt;.dex&lt;/em&gt;文件，在没有做代码混淆的情况下，很容易反汇编出Java源码，分析出代码逻辑。而且混淆也只是将类、方法、变量名称替换成&lt;em&gt;a&lt;/em&gt; &lt;em&gt;b&lt;/em&gt; &lt;em&gt;c&lt;/em&gt; &lt;em&gt;d&lt;/em&gt;这种没有任何意义的名字，增加理解难度而已。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;编译型语言&lt;/code&gt;(如C/C++，Objective-C等)最终编译出来的机器代码就比较复杂，因为其机器代码是跟CPU架构相关的，因此针对不同的CPU架构编译出来的二进制文件是不同的，反汇编得到的代码也会不一样。往往需要针对特定的CPU架构去解读汇编语言，才能正确的分析出结果出来，这就需要对不同架构CPU的寄存器、寻址方式等特性有所了解才行。另外二进制文件反汇编出来的函数、变量名通常是机器生成的无意义字符串，所以分析难度通常相较于解释型语言会更大一些。&lt;/p&gt;

&lt;h2 id=&quot;分析手段&quot;&gt;分析手段&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;常用的分析手段有以下三种：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;静态分析&lt;/li&gt;
  &lt;li&gt;动态分析&lt;/li&gt;
  &lt;li&gt;网络流量分析&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;猜&lt;/strong&gt;【你没有看错】&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在做逆向的时候，通常需要根据需要被分析的程序特点，选择一种或者多种手段结合使用，来达到最佳效果。&lt;/p&gt;

&lt;h3 id=&quot;静态分析&quot;&gt;静态分析&lt;/h3&gt;

&lt;p&gt;将机器代码反汇编成方便人类理解的代码，如smali代码（Java）、汇编代码或汇编代码翻译的C语言伪代码等等，通过分析这些比较低级的编程语言的代码，找到程序的业务流程或设计逻辑。&lt;/p&gt;

&lt;h3 id=&quot;动态分析&quot;&gt;动态分析&lt;/h3&gt;

&lt;p&gt;通过断点调试手段，让程序单步执行进行分析。动态分析往往是在静态分析出一定的结果的基础上进行，找到合适的地方给代码打断点，即时地读取当前变量的值，来进一步分析程序的逻辑、获取程序关系数据。&lt;/p&gt;

&lt;h3 id=&quot;网络流量分析&quot;&gt;网络流量分析&lt;/h3&gt;

&lt;p&gt;通过代理方式或者其他方式，截取程序与服务器通信的数据流量（抓包），来分析客户端和服务端的通信协议。网络流量分析比较有局限性，若客户端使用&lt;em&gt;Http&lt;/em&gt;这种明文传输的协议，会比较容易分析；但如果客户端使用SSL、&lt;em&gt;Https&lt;/em&gt;等加密传输协议与服务端进行通信，那么抓包的前提是需要拿到服务端下发给客户端的证书才能进一步解密分析，这种情况下就比较棘手。网上有方案通过安装插件拿到Chrome或者Firefox浏览器的本地证书，但只适用于客户端是网页的情况。若其他大佬有好的宝贵经验，还望能指点迷津。&lt;/p&gt;

&lt;h3 id=&quot;猜&quot;&gt;猜&lt;/h3&gt;

&lt;p&gt;正如上文所提到的分析汇编代码，往往不需要所有代码都逐行逐句都分析，其实不仅仅是分析汇编，我们在逆向分析所有代码（汇编、smali、C伪代码）时，以上三种分析手段往往只用在分析一些关键的、主干思路代码。很多时候，一些不重要的、通用写法的代码，就需要凭借自己点编程经验猜测了，提高逆向分析效率。&lt;/p&gt;

&lt;p&gt;而&lt;strong&gt;猜测&lt;/strong&gt;的前提是，你需要有一定的编程经验，能够在逆向分析出一些代码后，对其上下的代码进行合理的推测，推测不出来的代码再通过以上手段分析。可以这么说，你的推测能力决定了你的逆向分析效率，而编程经验则是你猜测能力的基石。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;详细章节&quot;&gt;详细章节&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;reverse-engineering-android&quot;&gt;Java语言的逆向(Android APP)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;reverse-engineering-asm&quot;&gt;汇编语言简述(逆向工程)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;reverse-engineering-oc&quot;&gt;Objective-C语言的逆向(Mac OS)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;reverse-engineering-c_cxx&quot;&gt;C/C++二进制逆向&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 27 Jan 2020 00:00:00 +0800</pubDate>
        <link>//reverse-engineering-summary</link>
        <link href="/reverse-engineering-summary"/>
        <guid isPermaLink="true">/reverse-engineering-summary</guid>
      </item>
    
  </channel>
</rss>
